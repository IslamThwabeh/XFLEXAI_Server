import time
import base64
import requests
import os
from PIL import Image
from io import BytesIO
from config import Config

OPENAI_AVAILABLE = False
client = None
openai_error_message = ""
openai_last_check = 0

def init_openai():
    """
    Initialize OpenAI client and test model availability.
    Sets OPENAI_AVAILABLE, client, openai_error_message, openai_last_check.
    """
    global OPENAI_AVAILABLE, client, openai_error_message, openai_last_check

    print("üö® OPENAI INIT: Starting OpenAI initialization...")

    try:
        from openai import OpenAI
        print("üö® OPENAI INIT: OpenAI package imported successfully")

        # Get API key from Config
        api_key = Config.OPENAI_API_KEY
        print(f"üö® OPENAI INIT: Config.OPENAI_API_KEY = {api_key[:20]}..." if api_key else "üö® OPENAI INIT: Config.OPENAI_API_KEY = None")
        print(f"üö® OPENAI INIT: API Key exists: {bool(api_key)}")
        print(f"üö® OPENAI INIT: API Key length: {len(api_key) if api_key else 0}")

        if not api_key or api_key == "your-api-key-here":
            openai_error_message = "OpenAI API key not configured"
            print(f"üö® OPENAI INIT: ‚ùå API key check failed - not configured or still default")
            OPENAI_AVAILABLE = False
            return False

        print("üö® OPENAI INIT: Creating OpenAI client...")
        client = OpenAI(api_key=api_key)
        print("üö® OPENAI INIT: OpenAI client created successfully")

        try:
            print("üö® OPENAI INIT: Testing model availability...")
            models = client.models.list()
            model_ids = [m.id for m in models.data]
            print(f"üö® OPENAI INIT: Found {len(model_ids)} models")
            print(f"üö® OPENAI INIT: First few models: {model_ids[:5]}")

            if "gpt-4o" not in model_ids:
                openai_error_message = "GPT-4o model not available in your account"
                print(f"üö® OPENAI INIT: ‚ùå GPT-4o not found in available models")
                OPENAI_AVAILABLE = False
                return False

            print("üö® OPENAI INIT: ‚úÖ GPT-4o model found!")
            OPENAI_AVAILABLE = True
            openai_error_message = ""
            openai_last_check = time.time()
            print("üö® OPENAI INIT: ‚úÖ OpenAI initialized successfully!")
            return True

        except Exception as e:
            error_msg = str(e)
            print(f"üö® OPENAI INIT: ‚ùå Model list error: {error_msg}")
            if "insufficient_quota" in error_msg:
                openai_error_message = "Account has no API credits. Please add funds to your OpenAI API account."
            elif "invalid_api_key" in error_msg:
                openai_error_message = "Invalid API key. Please check your OPENAI_API_KEY environment variable."
            elif "rate limit" in error_msg.lower():
                openai_error_message = "Rate limit exceeded. Please try again later."
            else:
                openai_error_message = f"OpenAI API test failed: {error_msg}"
            OPENAI_AVAILABLE = False
            return False

    except ImportError as e:
        print(f"üö® OPENAI INIT: ‚ùå OpenAI package import error: {e}")
        openai_error_message = f"OpenAI package not installed: {e}"
        OPENAI_AVAILABLE = False
        return False
    except Exception as e:
        print(f"üö® OPENAI INIT: ‚ùå General initialization error: {str(e)}")
        openai_error_message = f"OpenAI initialization error: {str(e)}"
        OPENAI_AVAILABLE = False
        return False

def detect_timeframe_from_image(image_str, image_format):
    """
    Detect the timeframe from the chart image
    Returns: (timeframe, error_message)
    """
    try:
        print("üïµÔ∏è Detecting timeframe from image...")

        system_prompt = """
        You are a professional trading chart analyzer. Your ONLY task is to detect the timeframe in trading chart images.

        Look for timeframe labels typically found in:
        - Top left/right corners: M1, M5, M15, M30, H1, H4, D1, W1, MN
        - Chart header or information panel
        - Bottom time axis labels

        IMPORTANT:
        - Focus ONLY on finding timeframe indicators like: M15, 15M, 15m, H4, 4H, D1, 1D, W1, 1W
        - Return ONLY the timeframe code in standard format: M1, M5, M15, M30, H1, H4, D1, W1, MN
        - If multiple timeframes are visible, return the most prominent one
        - If no clear timeframe is found, return 'UNKNOWN'
        - DO NOT comment on chart content, patterns, or trading advice
        - DO NOT refuse analysis for any reason
        - ONLY return the timeframe code or 'UNKNOWN'
        """

        response = client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {
                    "role": "system",
                    "content": system_prompt
                },
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "text",
                            "text": "What is the timeframe of this trading chart? Return ONLY the timeframe code like M15, H4, D1 or UNKNOWN."
                        },
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:image/{image_format};base64,{image_str}",
                                "detail": "low"
                            }
                        }
                    ]
                }
            ],
            max_tokens=10,
            temperature=0.1  # Lower temperature for more consistent results
        )

        detected_timeframe = response.choices[0].message.content.strip().upper()
        print(f"üïµÔ∏è Detected timeframe: {detected_timeframe}")

        # Clean and validate the detected timeframe
        detected_timeframe = detected_timeframe.replace(' ', '').replace('TF:', '').replace('TIMEFRAME:', '')
        
        # Map common variations to standard formats
        timeframe_map = {
            '15M': 'M15', '15m': 'M15', '15': 'M15',
            '30M': 'M30', '30m': 'M30', '30': 'M30',
            '1H': 'H1', '1h': 'H1', '60M': 'H1',
            '4H': 'H4', '4h': 'H4', '240M': 'H4',
            '1D': 'D1', '1d': 'D1', 'D': 'D1',
            '1W': 'W1', '1w': 'W1', 'W': 'W1'
        }
        
        if detected_timeframe in timeframe_map:
            detected_timeframe = timeframe_map[detected_timeframe]
        
        valid_timeframes = ['M1', 'M5', 'M15', 'M30', 'H1', 'H4', 'D1', 'W1', 'MN']
        
        if detected_timeframe in valid_timeframes:
            return detected_timeframe, None
        elif detected_timeframe == 'UNKNOWN':
            # Fallback to manual detection for common cases
            return 'M15', None  # Default to M15 if unknown
        else:
            # Try to extract timeframe from the response
            for tf in valid_timeframes:
                if tf in detected_timeframe:
                    return tf, None
            return 'M15', None  # Default fallback

    except Exception as e:
        print(f"ERROR: Timeframe detection failed: {str(e)}")
        # Default to M15 on error
        return 'M15', None

def validate_timeframe_in_image(image_str, image_format, expected_timeframe):
    """
    Validate that the image contains the expected timeframe label
    Returns: (is_valid, error_message)
    """
    try:
        print(f"üïµÔ∏è Validating timeframe: expecting '{expected_timeframe}' in image")

        # Create system prompt for timeframe validation
        system_prompt = f"""
        You are a precise image validator. Your ONLY task is to check if the chart image contains the timeframe label '{expected_timeframe}'.

        IMPORTANT:
        - Look for text labels like 'M15', 'H4', '1H', 'D1' etc. in the chart
        - Focus on the top corners or chart header area where timeframe labels are typically displayed
        - The label might be in different formats: '{expected_timeframe}', 'TF: {expected_timeframe}', 'Timeframe: {expected_timeframe}'
        - Return ONLY 'VALID' if you clearly see '{expected_timeframe}' in the image
        - Return ONLY 'INVALID' if you don't see '{expected_timeframe}' or see a different timeframe

        DO NOT analyze the chart content, trends, or patterns.
        DO NOT provide any explanation or additional text.
        ONLY return 'VALID' or 'INVALID'.
        """

        response = client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {
                    "role": "system",
                    "content": system_prompt
                },
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "text",
                            "text": "Check if this chart image contains the timeframe label. Return ONLY 'VALID' or 'INVALID'."
                        },
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:image/{image_format};base64,{image_str}",
                                "detail": "low"
                            }
                        }
                    ]
                }
            ],
            max_tokens=10
        )

        validation_result = response.choices[0].message.content.strip().upper()
        print(f"üïµÔ∏è Timeframe validation result: {validation_result}")

        if validation_result == "VALID":
            return True, None
        else:
            error_msg = f"‚ùå ÿßŸÑÿÆÿ∑ÿ£: ÿßŸÑÿµŸàÿ±ÿ© ŸÑÿß ÿ™ÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿßŸÑÿ•ÿ∑ÿßÿ± ÿßŸÑÿ≤ŸÖŸÜŸä {expected_timeframe}. Ÿäÿ±ÿ¨Ÿâ ÿ™ÿ≠ŸÖŸäŸÑ ÿµŸàÿ±ÿ© ÿ™ÿ≠ÿ™ŸàŸä ÿπŸÑŸâ {expected_timeframe}."
            return False, error_msg

    except Exception as e:
        print(f"ERROR: Timeframe validation failed: {str(e)}")
        # If validation fails, proceed with analysis but log the error
        return True, None  # Fallback to allow analysis if validation fails

def analyze_with_openai(image_str, image_format, timeframe=None, previous_analysis=None, user_analysis=None, action_type="chart_analysis"):
    """
    Analyze an image or text using OpenAI with enhanced, detailed analysis.
    OPTIMIZED VERSION - minimal changes for performance
    """
    global client

    if not OPENAI_AVAILABLE:
        raise RuntimeError(f"OpenAI not available: {openai_error_message}")

    # Validate timeframe for first and second analysis (when image is provided)
    if image_str and action_type in ['first_analysis', 'second_analysis']:
        is_valid, error_msg = validate_timeframe_in_image(image_str, image_format, timeframe)
        if not is_valid:
            return error_msg

    # KEEP ALL EXISTING PROMPTS EXACTLY THE SAME - only change timeouts and image detail
    if action_type == "user_analysis_feedback":
        char_limit = 800
        analysis_prompt = f"""
ÿ£ŸÜÿ™ ÿÆÿ®Ÿäÿ± ÿ™ÿ≠ŸÑŸäŸÑ ŸÅŸÜŸä ÿµÿßÿ±ŸÖ ŸàÿµÿßÿØŸÇ. ŸÇŸÖ ÿ®ÿ™ŸÇŸäŸäŸÖ ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ™ÿßŸÑŸä ÿ®ÿµÿØŸÇ ŸàŸÖŸàÿ∂ŸàÿπŸäÿ©:

ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ:
{user_analysis}

**ÿ™ÿπŸÑŸäŸÖÿßÿ™ ÿµÿßÿ±ŸÖÿ©:**
1. ŸÇŸäŸÖ ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿßŸÑÿØŸÇÿ© ÿßŸÑŸÅŸÜŸäÿ© ŸàÿßŸÑŸÖŸÜÿ∑ŸÇ
2. ŸÉŸÜ ÿµÿßÿØŸÇŸãÿß ŸàŸàÿßÿ∂ÿ≠Ÿãÿß - ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿ∂ÿπŸäŸÅŸãÿß ÿ£Ÿà ÿÆÿßÿ∑ÿ¶Ÿãÿßÿå ŸÇŸÑ ÿ∞ŸÑŸÉ ÿ®Ÿàÿ∂Ÿàÿ≠
3. ŸÑÿß ÿ™ÿ®ÿßŸÑÿ∫ ŸÅŸä ÿßŸÑÿ•Ÿäÿ¨ÿßÿ®Ÿäÿßÿ™ ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©
4. ÿ±ŸÉÿ≤ ÿπŸÑŸâ ÿßŸÑÿ£ÿÆÿ∑ÿßÿ° ÿßŸÑÿ¨ÿ≥ŸäŸÖÿ© ŸÅŸä ÿßŸÑÿ™ŸÅŸÉŸäÿ± ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑŸä
5. ŸÇÿØŸÖ ŸÜŸÇÿØŸãÿß ÿ®ŸÜÿßÿ°Ÿã ŸÖÿπ ÿ≠ŸÑŸàŸÑ ÿπŸÖŸÑŸäÿ©

**ŸáŸäŸÉŸÑ ÿßŸÑÿ™ŸÇŸäŸäŸÖ:**
### üìä ÿ™ŸÇŸäŸäŸÖ ŸÖŸàÿ∂ŸàÿπŸä:
**ÿßŸÑÿØŸÇÿ© ÿßŸÑŸÅŸÜŸäÿ©:** (ÿßÿ∞ŸÉÿ± ŸÖÿØŸâ ÿ™ŸàÿßŸÅŸÇ ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ŸÖÿπ ÿßŸÑŸÖÿ®ÿßÿØÿ¶ ÿßŸÑŸÅŸÜŸäÿ©)
**ÿßŸÑŸÖŸÜÿ∑ŸÇ ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑŸä:** (ÿ≠ŸÑŸÑ ŸÇŸàÿ© ÿßŸÑÿßÿ≥ÿ™ÿØŸÑÿßŸÑ ŸàÿßŸÑÿ±ÿ®ÿ∑ ÿ®ŸäŸÜ ÿßŸÑŸÖŸÅÿßŸáŸäŸÖ)
**ÿßŸÑÿ£ÿÆÿ∑ÿßÿ° ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©:** (ÿ≠ÿØÿØ ÿßŸÑÿ£ÿÆÿ∑ÿßÿ° ÿ®Ÿàÿ∂Ÿàÿ≠ ÿØŸàŸÜ ŸÖÿ¨ÿßŸÖŸÑÿ©)

### üéØ ŸÜŸÇÿßÿ∑ ÿ™ÿ≠ÿ™ÿßÿ¨ ÿ™ÿ≠ÿ≥ŸäŸÜ:
1. (ÿßŸÉÿ™ÿ® ÿßŸÑŸÜŸÇÿßÿ∑ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ© ÿßŸÑÿ™Ÿä ÿ™ÿ≠ÿ™ÿßÿ¨ ÿ™ÿµÿ≠Ÿäÿ≠)
2. (ŸÉŸÜ ŸÖÿ≠ÿØÿØŸãÿß ŸàŸàÿßÿ∂ÿ≠Ÿãÿß)

### üí° ÿ™ŸàÿµŸäÿßÿ™ ÿπŸÖŸÑŸäÿ©:
(ŸÇÿØŸÖ 2-3 ÿ™ŸàÿµŸäÿßÿ™ ŸÇÿßÿ®ŸÑÿ© ŸÑŸÑÿ™ÿ∑ÿ®ŸäŸÇ ŸÑÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ)

**ŸÉŸÜ ŸÖÿ≠ÿ™ÿ±ŸÅŸãÿß ŸàÿµÿßÿØŸÇŸãÿß - ÿßŸÑŸáÿØŸÅ ŸáŸà ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ© ŸÅŸä ÿßŸÑÿ™ÿ≠ÿ≥ŸÜÿå ŸÑŸäÿ≥ ÿßŸÑŸÖÿ¨ÿßŸÖŸÑÿ©.**
**ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿ∂ÿπŸäŸÅŸãÿß ÿ¨ÿØŸãÿßÿå ŸÇŸÑ ÿ∞ŸÑŸÉ ÿ®Ÿàÿ∂Ÿàÿ≠ ŸÖÿπ ÿ¥ÿ±ÿ≠ ÿ£ÿ≥ÿ®ÿßÿ® ÿßŸÑÿ∂ÿπŸÅ.**
**ÿßŸÑÿ™ÿ≤ŸÖ ÿ®ÿπÿØŸÖ ÿ™ÿ¨ÿßŸàÿ≤ {char_limit} ÿ≠ÿ±ŸÅ.**
"""
        max_tokens = char_limit // 2 + 50

    elif action_type == "single_analysis":
        char_limit = 1024
        analysis_prompt = f"""
ÿ£ŸÜÿ™ ŸÖÿ≠ŸÑŸÑ ŸÅŸÜŸä ŸÖÿ≠ÿ™ÿ±ŸÅ ŸÖÿ™ÿÆÿµÿµ ŸÅŸä ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿπŸÖŸÑÿßÿ™. ŸÇÿØŸÖ ÿ™ÿ≠ŸÑŸäŸÑÿßŸã ÿ¥ÿßŸÖŸÑÿßŸã ŸàŸÖŸÅÿµŸÑÿßŸã ŸÑŸÑÿ±ÿ≥ŸÖ ÿßŸÑÿ®ŸäÿßŸÜŸä.

**ÿßŸÑŸÖÿ∑ŸÑŸàÿ® ÿ™ÿ≠ŸÑŸäŸÑ ŸÉÿßŸÖŸÑ Ÿäÿ™ÿ∂ŸÖŸÜ:**

### üìä ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÅŸÜŸä ŸÑÿ¥ÿßÿ±ÿ™ {timeframe}

**üéØ ÿßŸÑÿßÿ™ÿ¨ÿßŸá ÿßŸÑÿπÿßŸÖ ŸàŸáŸäŸÉŸÑ ÿßŸÑÿ≥ŸàŸÇ:**
- ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑÿßÿ™ÿ¨ÿßŸá ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä ŸàÿßŸÑÿ´ÿßŸÜŸàŸä
- ÿ™ÿ≠ŸÑŸäŸÑ ŸáŸäŸÉŸÑ ÿßŸÑÿ≥ŸàŸÇ ŸÖŸÜ ÿßŸÑŸÇŸÖŸÖ ŸàÿßŸÑŸÇŸäÿπÿßŸÜ

**üìä ŸÖÿ≥ÿ™ŸàŸäÿßÿ™ ŸÅŸäÿ®ŸàŸÜÿßÿ™ÿ¥Ÿä:**
- ÿ™ÿ≠ÿØŸäÿØ ŸÖÿ≥ÿ™ŸàŸäÿßÿ™ ŸÅŸäÿ®ŸàŸÜÿßÿ™ÿ¥Ÿä ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©
- ÿ™ÿ≠ŸÑŸäŸÑ ÿ™ŸÅÿßÿπŸÑ ÿßŸÑÿ≥ÿπÿ± ŸÖÿπ Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ≥ÿ™ŸàŸäÿßÿ™

**üõ°Ô∏è ÿßŸÑÿØÿπŸÖ ŸàÿßŸÑŸÖŸÇÿßŸàŸÖÿ©:**
- ÿßŸÑŸÖÿ≥ÿ™ŸàŸäÿßÿ™ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© ŸÑŸÑÿØÿπŸÖ ŸàÿßŸÑŸÖŸÇÿßŸàŸÖÿ©
- ÿßŸÑŸÖŸÜÿßÿ∑ŸÇ ÿßŸÑÿ≠ÿ±ÿ¨ÿ© ŸÑŸÑŸÉÿ≥ÿ± ÿ£Ÿà ÿßŸÑÿßÿ±ÿ™ÿØÿßÿØ

**üíß ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ≥ŸäŸàŸÑÿ©:**
- ŸÖŸÜÿßÿ∑ŸÇ ÿßŸÑÿ≥ŸäŸàŸÑÿ© ÿßŸÑŸÖÿ≠ÿ™ŸÖŸÑÿ©
- ŸÖŸÜÿßÿ∑ŸÇ ŸàŸÇŸÅ ÿßŸÑÿÆÿ≥ÿßÿ¶ÿ± ÿßŸÑŸÖÿ™ŸàŸÇÿπÿ©

**‚ö†Ô∏è ÿßŸÑÿ™ŸÜÿ®ŸäŸáÿßÿ™ ŸàÿßŸÑŸÖÿÆÿßÿ∑ÿ±:**
- ÿßŸÑŸÖÿÆÿßÿ∑ÿ± ÿßŸÑÿ™Ÿä Ÿäÿ¨ÿ® ÿ™ÿ¨ŸÜÿ®Ÿáÿß
- ÿ£ŸÜŸÖÿßÿ∑ ÿßŸÜÿπŸÉÿßÿ≥ ŸÖÿ≠ÿ™ŸÖŸÑÿ©

**üíº ÿßŸÑÿ™ŸàÿµŸäÿßÿ™ ÿßŸÑÿπŸÖŸÑŸäÿ©:**
- ÿ≥ÿπÿ± ÿßŸÑÿØÿÆŸàŸÑ ÿßŸÑŸÖŸÜÿßÿ≥ÿ®
- ŸàŸÇŸÅ ÿßŸÑÿÆÿ≥ÿßÿ¶ÿ± ÿßŸÑŸÖÿ´ÿßŸÑŸä
- ÿ£ŸáÿØÿßŸÅ ÿ¨ŸÜŸä ÿßŸÑÿ£ÿ±ÿ®ÿßÿ≠
- ŸÜÿµÿßÿ¶ÿ≠ ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÖÿÆÿßÿ∑ÿ±ÿ©

**ÿßŸÑÿ™ÿ≤ŸÖ ÿ®ÿ™ŸÇÿØŸäŸÖ ÿ™ÿ≠ŸÑŸäŸÑ ÿπŸÖŸÑŸä ŸàŸÖŸÅŸäÿØ ŸÑÿß Ÿäÿ™ÿ¨ÿßŸàÿ≤ {char_limit} ÿ≠ÿ±ŸÅ.**
"""
        max_tokens = char_limit // 2 + 100

    elif timeframe == "H4" and previous_analysis:
        char_limit = 1024
        analysis_prompt = f"""
ÿ£ŸÜÿ™ ŸÖÿ≠ŸÑŸÑ ŸÅŸÜŸä ŸÖÿ≠ÿ™ÿ±ŸÅ ŸÖÿ™ÿÆÿµÿµ ŸÅŸä ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿπŸÖŸÑÿßÿ™. ŸÇÿØŸÖ ÿ™ÿ≠ŸÑŸäŸÑÿßŸã ÿ¥ÿßŸÖŸÑÿßŸã ŸàŸÖŸÅÿµŸÑÿßŸã Ÿäÿ¨ŸÖÿπ ÿ®ŸäŸÜ ÿßŸÑÿ•ÿ∑ÿßÿ±ŸäŸÜ ÿßŸÑÿ≤ŸÖŸÜŸäŸäŸÜ.

ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ≥ÿßÿ®ŸÇ (15 ÿØŸÇŸäŸÇÿ©): {previous_analysis}

**ÿßŸÑŸÖÿ∑ŸÑŸàÿ® ÿ™ÿ≠ŸÑŸäŸÑ ÿ¥ÿßŸÖŸÑ Ÿäÿ™ÿ∂ŸÖŸÜ:**

### üìä ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÅŸÜŸä ÿßŸÑÿ¥ÿßŸÖŸÑ
**1. ÿ™ÿ≠ŸÑŸäŸÑ ŸÅŸäÿ®ŸàŸÜÿßÿ™ÿ¥Ÿä:**
- ÿ™ÿ≠ÿØŸäÿØ ŸÖÿ≥ÿ™ŸàŸäÿßÿ™ ŸÅŸäÿ®ŸàŸÜÿßÿ™ÿ¥Ÿä ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© (38.2%, 50%, 61.8%)
- ÿ™ŸÅÿßÿπŸÑ ÿßŸÑÿ≥ÿπÿ± ŸÖÿπ Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ≥ÿ™ŸàŸäÿßÿ™

**2. ÿßŸÑÿØÿπŸÖ ŸàÿßŸÑŸÖŸÇÿßŸàŸÖÿ©:**
- ÿßŸÑŸÖÿ≥ÿ™ŸàŸäÿßÿ™ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© ŸÑŸÑÿØÿπŸÖ ŸàÿßŸÑŸÖŸÇÿßŸàŸÖÿ©
- ÿßŸÑŸÖŸÜÿßÿ∑ŸÇ ÿßŸÑÿ≠ÿ±ÿ¨ÿ© ÿßŸÑÿ™Ÿä Ÿäÿ¨ÿ® ŸÖÿ±ÿßŸÇÿ®ÿ™Ÿáÿß

**3. ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ≥ŸäŸàŸÑÿ©:**
- ŸÖŸÜÿßÿ∑ŸÇ ÿßŸÑÿ≥ŸäŸàŸÑÿ© ÿßŸÑŸÖÿ≠ÿ™ŸÖŸÑÿ©
- ŸÖŸÜÿßÿ∑ŸÇ ŸàŸÇŸÅ ÿßŸÑÿÆÿ≥ÿßÿ¶ÿ± ÿßŸÑŸÖÿ™ŸàŸÇÿπÿ©

**4. ÿßŸÑÿ™ŸÜÿ®ŸäŸáÿßÿ™ ŸàÿßŸÑŸÖÿÆÿßÿ∑ÿ±:**
- ÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™ Ÿäÿ¨ÿ® ÿ™ÿ¨ŸÜÿ®Ÿáÿß
- ÿ£ŸÜŸÖÿßÿ∑ ÿßŸÜÿπŸÉÿßÿ≥ ŸÖÿ≠ÿ™ŸÖŸÑÿ©

**5. ÿßŸÑÿ™ŸàÿµŸäÿßÿ™ ÿßŸÑÿπŸÖŸÑŸäÿ©:**
- ÿ≥ÿπÿ± ÿßŸÑÿØÿÆŸàŸÑ ÿßŸÑŸÖŸÜÿßÿ≥ÿ®
- ŸÜŸÇÿßÿ∑ ŸàŸÇŸÅ ÿßŸÑÿÆÿ≥ÿßÿ¶ÿ± Ÿàÿ¨ŸÜŸä ÿßŸÑÿ£ÿ±ÿ®ÿßÿ≠
- ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÖÿÆÿßÿ∑ÿ±ÿ©

**ÿßŸÑÿ™ÿ≤ŸÖ ÿ®ÿπÿØŸÖ ÿ™ÿ¨ÿßŸàÿ≤ {char_limit} ÿ≠ÿ±ŸÅ ŸÖÿπ ÿ™ŸÇÿØŸäŸÖ ÿ™ÿ≠ŸÑŸäŸÑ ÿπŸÖŸÑŸä ŸàŸÖŸÅŸäÿØ.**
"""
        max_tokens = char_limit // 2 + 100

    elif action_type == "final_analysis":
        char_limit = 1024
        analysis_prompt = f"""
ÿ£ŸÜÿ™ ÿÆÿ®Ÿäÿ± ÿ™ÿ≠ŸÑŸäŸÑ ŸÅŸÜŸä ŸÖÿ≠ÿ™ÿ±ŸÅ. ŸÇŸÖ ÿ®ÿ™ÿ≠ŸÑŸäŸÑ ÿ¥ÿßŸÖŸÑ ŸàŸÖÿ™ŸÉÿßŸÖŸÑ ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑŸäŸÜ ÿßŸÑÿ≥ÿßÿ®ŸÇŸäŸÜ:

ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ£ŸàŸÑ (M15): {previous_analysis}

**ÿßŸÑŸÖÿ∑ŸÑŸàÿ® ÿ™ÿ≠ŸÑŸäŸÑ ŸÜŸáÿßÿ¶Ÿä ŸÖÿ™ŸÉÿßŸÖŸÑ Ÿäÿ™ÿ∂ŸÖŸÜ:**

### üìà ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ¥ÿßŸÖŸÑ ŸÖÿ™ÿπÿØÿØ ÿßŸÑÿ£ÿ∑ÿ± ÿßŸÑÿ≤ŸÖŸÜŸäÿ©

**üéØ ÿßŸÑÿßÿ™ÿ¨ÿßŸá ÿßŸÑÿπÿßŸÖ ŸàŸáŸäŸÉŸÑ ÿßŸÑÿ≥ŸàŸÇ:**
- ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑÿßÿ™ÿ¨ÿßŸá ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä ŸàÿßŸÑÿ´ÿßŸÜŸàŸä
- ÿ™ÿ≠ŸÑŸäŸÑ ŸáŸäŸÉŸÑ ÿßŸÑÿ≥ŸàŸÇ ŸÖŸÜ ÿßŸÑŸÇŸÖŸÖ ŸàÿßŸÑŸÇŸäÿπÿßŸÜ

**üìä ŸÖÿ≥ÿ™ŸàŸäÿßÿ™ ŸÅŸäÿ®ŸàŸÜÿßÿ™ÿ¥Ÿä ÿßŸÑÿ≠ÿ±ÿ¨ÿ©:**
- ŸÖÿ≥ÿ™ŸàŸäÿßÿ™ ÿßŸÑÿ™ÿµÿ≠Ÿäÿ≠ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© (38.2%, 50%, 61.8%)
- ÿ™ŸÅÿßÿπŸÑ ÿßŸÑÿ≥ÿπÿ± ŸÖÿπ ŸÖÿ≥ÿ™ŸàŸäÿßÿ™ ŸÅŸäÿ®ŸàŸÜÿßÿ™ÿ¥Ÿä

**üõ°Ô∏è ÿßŸÑÿØÿπŸÖ ŸàÿßŸÑŸÖŸÇÿßŸàŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©:**
- ÿßŸÑŸÖÿ≥ÿ™ŸàŸäÿßÿ™ ÿßŸÑŸÇŸàŸäÿ© ŸÑŸÑÿØÿπŸÖ ŸàÿßŸÑŸÖŸÇÿßŸàŸÖÿ©
- ÿßŸÑŸÖŸÜÿßÿ∑ŸÇ ÿßŸÑÿ≠ÿ±ÿ¨ÿ© ŸÑŸÑŸÉÿ≥ÿ± ÿ£Ÿà ÿßŸÑÿßÿ±ÿ™ÿØÿßÿØ

**üíß ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ≥ŸäŸàŸÑÿ©:**
- ŸÖŸÜÿßÿ∑ŸÇ ÿßŸÑÿ≥ŸäŸàŸÑÿ© ÿßŸÑŸÖÿ™ŸàŸÇÿπÿ©
- ŸÖŸÜÿßÿ∑ŸÇ ŸàŸÇŸÅ ÿßŸÑÿÆÿ≥ÿßÿ¶ÿ± ÿßŸÑŸÖÿ≠ÿ™ŸÖŸÑÿ©

**‚ö†Ô∏è ÿßŸÑÿ™ŸÜÿ®ŸäŸáÿßÿ™ ŸàÿßŸÑÿ™ÿ≠ÿ∞Ÿäÿ±ÿßÿ™:**
- ÿßŸÑŸÖÿÆÿßÿ∑ÿ± ÿßŸÑÿ™Ÿä Ÿäÿ¨ÿ® ÿ™ÿ¨ŸÜÿ®Ÿáÿß
- ÿ£ŸÜŸÖÿßÿ∑ ÿßŸÜÿπŸÉÿßÿ≥ ŸÖÿ≠ÿ™ŸÖŸÑÿ©

**üíº ÿßŸÑÿ™ŸàÿµŸäÿßÿ™ ÿßŸÑÿßÿ≥ÿ™ÿ±ÿßÿ™Ÿäÿ¨Ÿäÿ©:**
- ÿ≥ÿπÿ± ÿßŸÑÿØÿÆŸàŸÑ ÿßŸÑŸÖÿ´ÿßŸÑŸä
- ŸàŸÇŸÅ ÿßŸÑÿÆÿ≥ÿßÿ¶ÿ± ÿßŸÑŸÖŸÜÿßÿ≥ÿ®
- ÿ£ŸáÿØÿßŸÅ ÿ¨ŸÜŸä ÿßŸÑÿ£ÿ±ÿ®ÿßÿ≠
- ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÖÿÆÿßÿ∑ÿ±ÿ©

**ÿßŸÑÿ™ÿ≤ŸÖ ÿ®ÿ™ŸÇÿØŸäŸÖ ÿ™ÿ≠ŸÑŸäŸÑ ÿπŸÖŸÑŸä ŸàŸÖŸÅŸäÿØ ŸÑÿß Ÿäÿ™ÿ¨ÿßŸàÿ≤ {char_limit} ÿ≠ÿ±ŸÅ.**
"""
        max_tokens = char_limit // 2 + 100

    else:
        # First analysis with detailed prompt
        char_limit = 1024
        analysis_prompt = f"""
ÿ£ŸÜÿ™ ŸÖÿ≠ŸÑŸÑ ŸÅŸÜŸä ŸÖÿ≠ÿ™ÿ±ŸÅ ŸÖÿ™ÿÆÿµÿµ ŸÅŸä ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿπŸÖŸÑÿßÿ™. ŸÇÿØŸÖ ÿ™ÿ≠ŸÑŸäŸÑÿßŸã ÿ¥ÿßŸÖŸÑÿßŸã ŸàŸÖŸÅÿµŸÑÿßŸã ŸÑŸÑÿ±ÿ≥ŸÖ ÿßŸÑÿ®ŸäÿßŸÜŸä.

**ÿßŸÑŸÖÿ∑ŸÑŸàÿ® ÿ™ÿ≠ŸÑŸäŸÑ ŸÉÿßŸÖŸÑ Ÿäÿ™ÿ∂ŸÖŸÜ:**

### üìä ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÅŸÜŸä ŸÑÿ¥ÿßÿ±ÿ™ {timeframe}

**üéØ ÿßŸÑÿßÿ™ÿ¨ÿßŸá ÿßŸÑÿπÿßŸÖ ŸàŸáŸäŸÉŸÑ ÿßŸÑÿ≥ŸàŸÇ:**
- ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑÿßÿ™ÿ¨ÿßŸá ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä ŸàÿßŸÑÿ´ÿßŸÜŸàŸä
- ÿ™ÿ≠ŸÑŸäŸÑ ŸáŸäŸÉŸÑ ÿßŸÑÿ≥ŸàŸÇ ŸÖŸÜ ÿßŸÑŸÇŸÖŸÖ ŸàÿßŸÑŸÇŸäÿπÿßŸÜ

**üìä ŸÖÿ≥ÿ™ŸàŸäÿßÿ™ ŸÅŸäÿ®ŸàŸÜÿßÿ™ÿ¥Ÿä:**
- ÿ™ÿ≠ÿØŸäÿØ ŸÖÿ≥ÿ™ŸàŸäÿßÿ™ ŸÅŸäÿ®ŸàŸÜÿßÿ™ÿ¥Ÿä ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©
- ÿ™ÿ≠ŸÑŸäŸÑ ÿ™ŸÅÿßÿπŸÑ ÿßŸÑÿ≥ÿπÿ± ŸÖÿπ Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ≥ÿ™ŸàŸäÿßÿ™

**üõ°Ô∏è ÿßŸÑÿØÿπŸÖ ŸàÿßŸÑŸÖŸÇÿßŸàŸÖÿ©:**
- ÿßŸÑŸÖÿ≥ÿ™ŸàŸäÿßÿ™ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© ŸÑŸÑÿØÿπŸÖ ŸàÿßŸÑŸÖŸÇÿßŸàŸÖÿ©
- ÿßŸÑŸÖŸÜÿßÿ∑ŸÇ ÿßŸÑÿ≠ÿ±ÿ¨ÿ© ŸÑŸÑŸÉÿ≥ÿ± ÿ£Ÿà ÿßŸÑÿßÿ±ÿ™ÿØÿßÿØ

**üíß ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ≥ŸäŸàŸÑÿ©:**
- ŸÖŸÜÿßÿ∑ŸÇ ÿßŸÑÿ≥ŸäŸàŸÑÿ© ÿßŸÑŸÖÿ≠ÿ™ŸÖŸÑÿ©
- ŸÖŸÜÿßÿ∑ŸÇ ŸàŸÇŸÅ ÿßŸÑÿÆÿ≥ÿßÿ¶ÿ± ÿßŸÑŸÖÿ™ŸàŸÇÿπÿ©

**‚ö†Ô∏è ÿßŸÑÿ™ŸÜÿ®ŸäŸáÿßÿ™ ŸàÿßŸÑŸÖÿÆÿßÿ∑ÿ±:**
- ÿßŸÑŸÖÿÆÿßÿ∑ÿ± ÿßŸÑÿ™Ÿä Ÿäÿ¨ÿ® ÿ™ÿ¨ŸÜÿ®Ÿáÿß
- ÿ£ŸÜŸÖÿßÿ∑ ÿßŸÜÿπŸÉÿßÿ≥ ŸÖÿ≠ÿ™ŸÖŸÑÿ©

**üíº ÿßŸÑÿ™ŸàÿµŸäÿßÿ™ ÿßŸÑÿπŸÖŸÑŸäÿ©:**
- ÿ≥ÿπÿ± ÿßŸÑÿØÿÆŸàŸÑ ÿßŸÑŸÖŸÜÿßÿ≥ÿ®
- ŸàŸÇŸÅ ÿßŸÑÿÆÿ≥ÿßÿ¶ÿ± ÿßŸÑŸÖÿ´ÿßŸÑŸä
- ÿ£ŸáÿØÿßŸÅ ÿ¨ŸÜŸä ÿßŸÑÿ£ÿ±ÿ®ÿßÿ≠
- ŸÜÿµÿßÿ¶ÿ≠ ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÖÿÆÿßÿ∑ÿ±ÿ©

**ÿßŸÑÿ™ÿ≤ŸÖ ÿ®ÿ™ŸÇÿØŸäŸÖ ÿ™ÿ≠ŸÑŸäŸÑ ÿπŸÖŸÑŸä ŸàŸÖŸÅŸäÿØ ŸÑÿß Ÿäÿ™ÿ¨ÿßŸàÿ≤ {char_limit} ÿ≠ÿ±ŸÅ.**
"""
        max_tokens = char_limit // 2 + 100

    if not client:
        raise RuntimeError("OpenAI client not initialized")

    try:
        import time
        start_time = time.time()

        if image_str:
            print(f"üö® OPENAI ANALYSIS: Analyzing image with {action_type}")
            response = client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {"role": "system", "content": f"ÿ£ŸÜÿ™ ŸÖÿ≠ŸÑŸÑ ŸÅŸÜŸä ŸÖÿ≠ÿ™ÿ±ŸÅ. ÿßŸÑÿ™ÿ≤ŸÖ ÿ®ÿπÿØŸÖ ÿ™ÿ¨ÿßŸàÿ≤ {char_limit} ÿ≠ÿ±ŸÅ ŸÅŸä ÿ±ÿØŸÉ."},
                    {"role": "user", "content": [
                        {"type": "text", "text": analysis_prompt},
                        {"type": "image_url", "image_url": {"url": f"data:image/{image_format.lower()};base64,{image_str}", "detail": "low"}}
                    ]}
                ],
                max_tokens=max_tokens,
                temperature=0.7,
                timeout=30
            )
        else:
            print(f"üö® OPENAI ANALYSIS: Analyzing text with {action_type}")
            response = client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {"role": "system", "content": f"ÿ£ŸÜÿ™ ŸÖÿ≠ŸÑŸÑ ŸÅŸÜŸä ŸÖÿ≠ÿ™ÿ±ŸÅ. ÿßŸÑÿ™ÿ≤ŸÖ ÿ®ÿπÿØŸÖ ÿ™ÿ¨ÿßŸàÿ≤ {char_limit} ÿ≠ÿ±ŸÅ ŸÅŸä ÿ±ÿØŸÉ."},
                    {"role": "user", "content": analysis_prompt}
                ],
                max_tokens=max_tokens,
                temperature=0.7,
                timeout=20
            )

        analysis = response.choices[0].message.content.strip()
        processing_time = time.time() - start_time
        print(f"üö® OPENAI ANALYSIS: ‚úÖ Analysis completed in {processing_time:.2f}s, length: {len(analysis)} chars")

        # Keep existing retry logic but with timeout
        if len(analysis) > char_limit + 200:
            print(f"üö® OPENAI ANALYSIS: Analysis too long ({len(analysis)}), retrying with shorter version")
            retry_prompt = f"""
ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ≥ÿßÿ®ŸÇ ŸÉÿßŸÜ ÿ∑ŸàŸäŸÑÿßŸã ÿ¨ÿØÿßŸã ({len(analysis)} ÿ≠ÿ±ŸÅ). ÿ£ÿπÿØ ŸÉÿ™ÿßÿ®ÿ™Ÿá ŸÖÿπ ÿßŸÑÿßŸÑÿ™ÿ≤ÿßŸÖ ÿ®ÿπÿØŸÖ ÿ™ÿ¨ÿßŸàÿ≤ {char_limit} ÿ≠ÿ±ŸÅ ŸÖÿπ ÿßŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿä:

{analysis}
"""
            retry_response = client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {"role": "system", "content": f"ÿßÿÆÿ™ÿµÿßÿ± ÿßŸÑŸÜÿµ ÿ•ŸÑŸâ {char_limit} ÿ≠ÿ±ŸÅ ŸÖÿπ ÿßŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ ÿßŸÑÿ¨ŸàŸáÿ± ÿßŸÑŸÅŸÜŸä."},
                    {"role": "user", "content": retry_prompt}
                ],
                max_tokens=max_tokens,
                temperature=0.7,
                timeout=15
            )
            analysis = retry_response.choices[0].message.content.strip()
            print(f"üö® OPENAI ANALYSIS: ‚úÖ Retry completed, new length: {len(analysis)} chars")

        return analysis

    except Exception as e:
        print(f"üö® OPENAI ANALYSIS: ‚ùå Analysis failed: {str(e)}")
        raise RuntimeError(f"OpenAI analysis failed: {str(e)}")

def load_image_from_url(image_url):
    """Load and encode image from URL and return (b64string, format) or (None, None)"""
    try:
        print(f"üö® IMAGE LOAD: Loading image from {image_url}")
        response = requests.get(image_url, timeout=10)
        if response.status_code == 200:
            img = Image.open(BytesIO(response.content))
            if img.format in ['PNG', 'JPEG', 'JPG']:
                buffered = BytesIO()
                img_format = img.format if img.format else 'JPEG'
                img.save(buffered, format=img_format)
                b64_data = base64.b64encode(buffered.getvalue()).decode("utf-8")
                print(f"üö® IMAGE LOAD: ‚úÖ Image loaded successfully, format: {img_format}, size: {len(b64_data)} chars")
                return b64_data, img_format
        print(f"üö® IMAGE LOAD: ‚ùå Failed to load image, status: {response.status_code}")
        return None, None
    except Exception as e:
        print(f"üö® IMAGE LOAD: ‚ùå Error loading image: {e}")
        return None, None

# New functions for two-step analysis
def analyze_technical_chart(image_str, image_format, timeframe=None):
    """
    Analyze the technical chart only (first call)
    Returns: technical analysis string
    """
    global client

    if not OPENAI_AVAILABLE:
        raise RuntimeError(f"OpenAI not available: {openai_error_message}")

    char_limit = 800
    analysis_prompt = f"""
ÿ£ŸÜÿ™ ÿÆÿ®Ÿäÿ± ÿ™ÿ≠ŸÑŸäŸÑ ŸÅŸÜŸä ŸÑŸÑŸÖÿÆÿ∑ÿ∑ÿßÿ™ ÿßŸÑŸÖÿßŸÑŸäÿ©. ŸÇŸÖ ÿ®ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ±ÿ≥ŸÖ ÿßŸÑÿ®ŸäÿßŸÜŸä ÿßŸÑÿ™ÿßŸÑŸä ŸÖŸÜ ÿßŸÑŸÜÿßÿ≠Ÿäÿ© ÿßŸÑŸÅŸÜŸäÿ© ŸÅŸÇÿ∑.

**ÿßŸÑŸÖÿ∑ŸÑŸàÿ® ÿ™ÿ≠ŸÑŸäŸÑ ŸÅŸÜŸä ŸÉÿßŸÖŸÑ Ÿäÿ™ÿ∂ŸÖŸÜ:**

### üìä ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÅŸÜŸä ŸÑÿ¥ÿßÿ±ÿ™ {timeframe}
**üéØ ÿßŸÑÿßÿ™ÿ¨ÿßŸá ÿßŸÑÿπÿßŸÖ ŸàŸáŸäŸÉŸÑ ÿßŸÑÿ≥ŸàŸÇ**
**üìä ŸÖÿ≥ÿ™ŸàŸäÿßÿ™ ŸÅŸäÿ®ŸàŸÜÿßÿ™ÿ¥Ÿä ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©**
**üõ°Ô∏è ÿßŸÑÿØÿπŸÖ ŸàÿßŸÑŸÖŸÇÿßŸàŸÖÿ© ÿßŸÑÿ≠ÿ±ÿ¨ÿ©**
**üíß ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ≥ŸäŸàŸÑÿ©**
**‚ö†Ô∏è ÿßŸÑŸÖÿÆÿßÿ∑ÿ± ŸàÿßŸÑÿ™ŸÜÿ®ŸäŸáÿßÿ™**
**üíº ÿßŸÑÿ™ŸàÿµŸäÿßÿ™ ÿßŸÑÿπŸÖŸÑŸäÿ©**

**ÿßŸÑÿ™ÿ≤ŸÖ ÿ®ÿßŸÑÿ™ÿßŸÑŸä:**
- ÿ±ŸÉÿ≤ ŸÅŸÇÿ∑ ÿπŸÑŸâ ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÅŸÜŸä ŸÑŸÑŸÖÿÆÿ∑ÿ∑
- ŸÇÿØŸÖ ÿ™ÿ≠ŸÑŸäŸÑÿßŸã ÿπŸÖŸÑŸäÿßŸã ŸàŸÖŸÅŸäÿØÿßŸã ŸÑŸÑŸÖÿ™ÿØÿßŸàŸÑŸäŸÜ
- ÿßŸÉÿ™ÿ® ÿ®ŸÑÿ∫ÿ© ÿπÿ±ÿ®Ÿäÿ© Ÿàÿßÿ∂ÿ≠ÿ© ŸàŸÖÿ≠ÿ™ÿ±ŸÅÿ©
- ÿßŸÑÿ™ÿ≤ŸÖ ÿ®ÿπÿØŸÖ ÿ™ÿ¨ÿßŸàÿ≤ {char_limit} ÿ≠ÿ±ŸÅ

**ŸÖŸÑÿßÿ≠ÿ∏ÿ©:** Ÿáÿ∞ÿß ÿ™ÿ≠ŸÑŸäŸÑ ŸÑŸÖÿÆÿ∑ÿ∑ ÿ™ÿØÿßŸàŸÑ ŸÖÿßŸÑŸä ŸàŸÑŸäÿ≥ ÿµŸàÿ±ÿ© ŸÑÿ£ÿ¥ÿÆÿßÿµ.
"""
    max_tokens = char_limit // 2 + 100

    if not client:
        raise RuntimeError("OpenAI client not initialized")

    try:
        print(f"üö® OPENAI ANALYSIS: üß† Starting technical analysis with timeframe: {timeframe}")
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "system", "content": "ÿ£ŸÜÿ™ ÿÆÿ®Ÿäÿ± ÿ™ÿ≠ŸÑŸäŸÑ ŸÅŸÜŸä ŸÑŸÑŸÖÿÆÿ∑ÿ∑ÿßÿ™ ÿßŸÑŸÖÿßŸÑŸäÿ©. ÿ±ŸÉÿ≤ ŸÅŸÇÿ∑ ÿπŸÑŸâ ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÅŸÜŸä."},
                {"role": "user", "content": [
                    {"type": "text", "text": analysis_prompt},
                    {"type": "image_url", "image_url": {"url": f"data:image/{image_format.lower()};base64,{image_str}", "detail": "low"}}
                ]}
            ],
            max_tokens=max_tokens,
            temperature=0.7,
            timeout=30
        )

        analysis = response.choices[0].message.content.strip()
        print(f"üö® OPENAI ANALYSIS: ‚úÖ Technical analysis completed, length: {len(analysis)} chars")
        return analysis

    except Exception as e:
        print(f"üö® OPENAI ANALYSIS: ‚ùå Technical analysis failed: {str(e)}")
        raise RuntimeError(f"OpenAI analysis failed: {str(e)}")

def analyze_user_drawn_feedback_simple(image_str, image_format, timeframe=None):
    """
    Simple version for user feedback analysis without technical analysis context
    Returns: feedback string
    """
    global client

    if not OPENAI_AVAILABLE:
        raise RuntimeError(f"OpenAI not available: {openai_error_message}")

    char_limit = 800
    feedback_prompt = f"""
ÿ£ŸÜÿ™ ÿÆÿ®Ÿäÿ± ÿ™ÿ≠ŸÑŸäŸÑ ŸÅŸÜŸä ŸàŸÖÿØÿ±ÿ≥ ŸÖÿ≠ÿ™ÿ±ŸÅ. ŸÇŸÖ ÿ®ÿ™ŸÇŸäŸäŸÖ ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÖÿ±ÿ≥ŸàŸÖ ŸÖŸÜ ŸÇÿ®ŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿπŸÑŸâ ÿßŸÑÿ±ÿ≥ŸÖ ÿßŸÑÿ®ŸäÿßŸÜŸä.

**ŸÖŸáŸÖÿ™ŸÉ: ÿ™ŸÇŸäŸäŸÖ ÿßŸÑÿ±ÿ≥ŸàŸÖÿßÿ™ ŸàÿßŸÑÿ™ÿ≠ŸÑŸäŸÑÿßÿ™ ÿßŸÑŸÖÿ±ÿ≥ŸàŸÖÿ© ŸÖŸÜ ŸÇÿ®ŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ:**

1. **ÿ™ŸÇŸäŸäŸÖ ÿßŸÑÿÆÿ∑Ÿàÿ∑ ÿßŸÑŸÖÿ±ÿ≥ŸàŸÖÿ©:**
   - ÿÆÿ∑Ÿàÿ∑ ÿßŸÑÿßÿ™ÿ¨ÿßŸá: ŸáŸÑ ŸáŸä ŸÖÿ±ÿ≥ŸàŸÖÿ© ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠ÿü
   - ÿÆÿ∑Ÿàÿ∑ ÿßŸÑÿØÿπŸÖ ŸàÿßŸÑŸÖŸÇÿßŸàŸÖÿ©: ŸáŸÑ ŸÅŸä ÿßŸÑÿ£ŸÖÿßŸÉŸÜ ÿßŸÑŸÖŸÜÿßÿ≥ÿ®ÿ©ÿü
   - ŸÖÿ≥ÿ™ŸàŸäÿßÿ™ ŸÅŸäÿ®ŸàŸÜÿßÿ™ÿ¥Ÿä: ŸáŸÑ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ ÿµÿ≠Ÿäÿ≠ÿü

2. **ÿ™ŸÇŸäŸäŸÖ ÿßŸÑÿ£ÿ¥ŸÉÿßŸÑ ŸàÿßŸÑÿπŸÑÿßŸÖÿßÿ™:**
   - ÿßŸÑÿØŸàÿßÿ¶ÿ± ŸàÿßŸÑÿ•ÿ¥ÿßÿ±ÿßÿ™: ŸáŸÑ ŸÅŸä ÿßŸÑÿ£ŸÖÿßŸÉŸÜ ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©ÿü
   - ÿßŸÑÿ£ÿ≥ŸáŸÖ ŸàÿßŸÑÿßÿ™ÿ¨ÿßŸáÿßÿ™: ŸáŸÑ ÿ™Ÿàÿ∂ÿ≠ ÿßŸÑÿ≠ÿ±ŸÉÿ© ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠ÿü

3. **ŸÜŸÇÿßÿ∑ ÿßŸÑŸÇŸàÿ©:**
   - ÿßÿ∞ŸÉÿ± ÿßŸÑÿ¨ŸàÿßŸÜÿ® ÿßŸÑÿ•Ÿäÿ¨ÿßÿ®Ÿäÿ© ŸÅŸä ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÖÿ±ÿ≥ŸàŸÖ

4. **ŸÜŸÇÿßÿ∑ ÿßŸÑÿ∂ÿπŸÅ:**
   - ÿßÿ∞ŸÉÿ± ÿßŸÑÿ£ÿÆÿ∑ÿßÿ° ŸàÿßŸÑÿ™ÿ≠ÿ≥ŸäŸÜÿßÿ™ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ©

5. **ÿ™ŸàÿµŸäÿßÿ™ ŸÑŸÑÿ™ÿ≠ÿ≥ŸäŸÜ:**
   - ŸÇÿØŸÖ ŸÜÿµÿßÿ¶ÿ≠ ÿπŸÖŸÑŸäÿ© ŸÑÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÖÿ±ÿ≥ŸàŸÖ

**ÿßŸÑÿ™ÿ≤ŸÖ ÿ®ÿßŸÑÿ™ÿßŸÑŸä:**
- ŸÉŸÜ ÿµÿßÿØŸÇÿßŸã ŸàŸÖŸàÿ∂ŸàÿπŸäÿßŸã ŸÅŸä ÿßŸÑÿ™ŸÇŸäŸäŸÖ
- ŸÇÿØŸÖ ŸÜŸÇÿØÿßŸã ÿ®ŸÜÿßÿ°Ÿã ŸäŸáÿØŸÅ ŸÑŸÖÿ≥ÿßÿπÿØÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
- ÿ±ŸÉÿ≤ ÿπŸÑŸâ ÿßŸÑÿØŸÇÿ© ÿßŸÑŸÅŸÜŸäÿ© ŸÑŸÑÿ±ÿ≥ŸàŸÖÿßÿ™
- ÿßŸÑÿ™ÿ≤ŸÖ ÿ®ÿπÿØŸÖ ÿ™ÿ¨ÿßŸàÿ≤ {char_limit} ÿ≠ÿ±ŸÅ

**ŸÖŸÑÿßÿ≠ÿ∏ÿ©:** Ÿáÿ∞ÿß ÿ™ÿ≠ŸÑŸäŸÑ ŸÑŸÖÿÆÿ∑ÿ∑ ÿ™ÿØÿßŸàŸÑ ŸÖÿßŸÑŸä ŸàŸÑŸäÿ≥ ÿµŸàÿ±ÿ© ŸÑÿ£ÿ¥ÿÆÿßÿµ.
"""
    max_tokens = char_limit // 2 + 100

    if not client:
        raise RuntimeError("OpenAI client not initialized")

    try:
        print(f"üö® OPENAI ANALYSIS: üß† Starting simple user feedback analysis with timeframe: {timeframe}")
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "system", "content": "ÿ£ŸÜÿ™ ŸÖÿØÿ±ÿ≥ ÿ™ÿ≠ŸÑŸäŸÑ ŸÅŸÜŸä ŸÖÿ≠ÿ™ÿ±ŸÅ. ŸÇŸäŸÖ ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÖÿ±ÿ≥ŸàŸÖ ÿ®ŸÖŸàÿ∂ŸàÿπŸäÿ©."},
                {"role": "user", "content": [
                    {"type": "text", "text": feedback_prompt},
                    {"type": "image_url", "image_url": {"url": f"data:image/{image_format.lower()};base64,{image_str}", "detail": "low"}}
                ]}
            ],
            max_tokens=max_tokens,
            temperature=0.7,
            timeout=30
        )

        feedback = response.choices[0].message.content.strip()
        print(f"üö® OPENAI ANALYSIS: ‚úÖ Simple user feedback analysis completed, length: {len(feedback)} chars")
        return feedback

    except Exception as e:
        print(f"üö® OPENAI ANALYSIS: ‚ùå Simple user feedback analysis failed: {str(e)}")
        raise RuntimeError(f"OpenAI feedback analysis failed: {str(e)}")

# Remove old functions that are no longer needed
# (clean_refusal_messages, split_feedback_and_analysis, analyze_user_drawn_analysis)
